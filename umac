#!/usr/bin/perl -w -- -*-Perl-*-

##############################################################################
#
#                                 umac
#
# DESCRIPTION:
# Ultimate Multiple Alignment Converter
#
##############################################################################

##############################################################################
#
#    $Id: umac,v 1.19 2010/02/19 23:16:43 nbeck Exp $
#
#    $Log: umac,v $
#    Revision 1.19  2010/02/19 23:16:43  nbeck
#    Added option -n and added verification for STOCKHOLM format.
#
#    Revision 1.18  2010/02/19 22:31:51  nbeck
#    Fixed bug about last STOCKHOLM block.
#
#    Revision 1.17  2010/02/18 21:42:16  nbeck
#    Changed ReadStockholmMultAligns in order to fix some bug.
#
#    Revision 1.16  2010/02/01 20:42:17  nbeck
#    Optimization of sub FilteringStockholm.
#
#    Revision 1.15  2010/01/29 18:48:09  nbeck
#    Change path for esl-alimanip.
#
#    Revision 1.14  2010/01/29 16:46:17  nbeck
#    Fixed bug when reading STOCKHOLM.
#
#    Revision 1.13  2010/01/29 15:09:03  nbeck
#    Fixed bug for filtering option.
#
#    Revision 1.12  2010/01/28 21:45:47  nbeck
#    Added support for Stockholm input.
#
#    Revision 1.11  2008/03/04 18:15:40  riouxp
#    Adjusted FASTA parser to make some blanks non-significant.
#
#    Revision 1.10  2007/04/30 17:07:08  riouxp
#    Fixed output length to 100 in Stockholm format.
#
#    Revision 1.9  2007/04/30 16:37:32  riouxp
#    Added support for #GC RF line in stockholm format.
#
#    Revision 1.8  2007/04/27 18:12:12  riouxp
#    Added preliminary support for Stockholm format (output only)
#    with a single structure line (#=GC SS_cons).
#
#    Revision 1.7  2007/04/20 17:02:12  riouxp
#    Added RAW format (output only).
#
#    Revision 1.6  2007/04/19 19:16:19  riouxp
#    Added option -K to make all non-blank characters significant in
#    alignments.
#
#    Revision 1.5  2007/04/18 18:24:37  riouxp
#    Added support for GDE format (output only for the moment).
#
#    Revision 1.4  2007/04/16 16:49:05  riouxp
#    Added support for CLUSTAL format.
#
#    Revision 1.3  2007/02/21 20:55:28  hourlier
#    Added one blank line as an example.
#
#    Revision 1.2  2006/11/29 21:54:43  riouxp
#    Fixed list of progs/formats.
#
#    Revision 1.1  2006/11/28 16:33:35  riouxp
#    Newly checked-in.
#

##########################
# Initialization section #
##########################

require 5.00;
use strict;
use vars qw( $VERSION $RCS_VERSION $DEBUG );
use PirObject qw( MultAlign );
use IO::File;
use IO::Dir;
use File::Path;

# Default umask
umask 027;

# Program's name and version number.
$RCS_VERSION='$Id: umac,v 1.19 2010/02/19 23:16:43 nbeck Exp $';
($VERSION) = ($RCS_VERSION =~ m#,v ([\w\.]+)#);
my ($BASENAME) = ($0 =~ /([^\/]+)$/);

# Get login name.
my $USER=getpwuid($<) || getlogin || die "Can't find USER from environment!\n";

##################################
# Global variables and constants #
##################################

$|=1;
$DEBUG=0;

# Arguments from command-line
my $INFILE="";
my $OUTFILE="";
my $FORMAT="";
my $PROGRAM="";
my $TMPDIR="";
my $VERBOSE=0;
my $VALIDATE=0;
my $KEEPALLCHARS=0;
my $STRUCTURES=0;
my $FILTERING=0;
my $GLOBALPERCENT='*';
my $LOCALPERCENT='*';
my $DASHPERCENT=70;

# Long decription of each format's short keyword
my %FORMAT_LONG = (
    "Phylip-N"  => "Phylip non-interleaved",
    "Phylip-I"  => "Phylip interleaved",
    "FASTA"     => "FASTA (Pearson)",
    "NEXUS"     => "NEXUS (Paup)",
    "CLUSTAL"   => "Clustal W (interleaved)",
    "GDE"       => "GDE",
    "RAW"       => "Raw (one line per seq)",
    "STOCKHOLM" => "Stockholm (interleaved)",
);

my %PROG_TO_FORMAT = (
    "pb"       => "Phylip-N",
    "RAxMLHPC" => "Phylip-I",
    "IQPNNI"   => "Phylip-I",
    "jknife"   => "FASTA",
    "phyms"    => "FASTA",
    "paup"     => "NEXUS",
    "clustalw" => "CLUSTAL",
    "gde"      => "GDE",
    "RNAfold"  => "RAW",
    "hmmer"    => "STOCKHOLM",
    "infernal" => "STOCKHOLM",
);

my %FORMAT_TO_PROGS = ();
foreach my $prog (keys %PROG_TO_FORMAT) {
    my $format = $PROG_TO_FORMAT{$prog};
    $FORMAT_TO_PROGS{$format} ||= [];
    push(@{$FORMAT_TO_PROGS{$format}},$prog);
}

# CREATE THE TMPDIR #
$TMPDIR = "/tmp/umac.$$" if !$TMPDIR;
if (! -d $TMPDIR) {
    mkdir($TMPDIR,0700) or die "Error: can't create work directory '$TMPDIR': $!\n";
}

#####################################
# Command-Line Arguments Processing #
#####################################

sub Usage {
    print "This is $BASENAME $VERSION\n",
          "\n",
          "Usage: $BASENAME [-@[n]] [-v] [-c] [-K] [-S #] [-f format|-p program] [-i infile] [-o outfile] [-F -g global_percent -s sp_percent -n nt_percent]\n",
          "\n",
          "   -i is the input file, containing one or many multiple alignments\n",
          "   -o is the output file, converted\n",
          "   -f is the output format\n",
          "   -p is an alternative to -f, where you specify which external program\n",
          "      will use this output; the -f format will be selected for you\n",
          "   -v makes the program more verbose\n",
          "   -c tells the program to check the alignments for errors/inconsistencies\n",
          "   -K tells the program to allow any and all non blank characters in sequence data\n",
          "   -S # indicates that the first # sequences are structure descriptions\n",
          "   -F use filter for STOCKHOLM if only -F is defined used default value for -g, -n, -s\n",
          "   -g retain sequence columns that are of value defined in g (*,9,8...;  #=GC PP_cons default: '*')\n",
          "   -n retain sequence columns with a percentage of sequence characters larger than or equal as defined in n (default: 70% retain)\n",
          "   -s replace sequences for every species that are worse than the value defined default: '*'\n",
          "\n",
          "Leaving -i and/or -o blank or supplying a single '-' can be used\n",
          "to mean STDIN or STDOUT for the files.\n",
          "\n";
    &ListKnownFormats();
    exit 20;
}

&Usage if @ARGV == 0;

for (;@ARGV;) {
    my ($opt,$arg) = ($ARGV[0] =~ /^-([\@iofpvcnKSFgs])(.*)$/o);
    last if ! defined $opt;
    if ($opt =~ /[iofpnSgs]/ && $arg eq "") {
        if (@ARGV < 2) {
            print "Argument required for switch \"-$opt\".\n";
            exit 1;
        }
        shift @ARGV;
        $arg=$ARGV[0];
    }

    $DEBUG=(defined($arg) ? $arg : 1)             if $opt eq '@';

    $INFILE=$arg                                  if $opt eq 'i';
    $OUTFILE=$arg                                 if $opt eq 'o';
    $FORMAT=$arg                                  if $opt eq 'f';
    $PROGRAM=$arg                                 if $opt eq 'p';
    $VERBOSE++                                    if $opt eq 'v';
    $VALIDATE=1                                   if $opt eq 'c';
    $KEEPALLCHARS=1                               if $opt eq 'K';
    $STRUCTURES=$arg                              if $opt eq 'S';
    $FILTERING=1                                  if $opt eq 'F';
    $GLOBALPERCENT=$arg                           if $opt eq 'g';
    $LOCALPERCENT=$arg                            if $opt eq 's';
    $DASHPERCENT=$arg                             if $opt eq 'n';

    shift @ARGV;
}

die "Must add -F option if you want use -g or -s or -p\n"
    if $FILTERING == 0 && ( $GLOBALPERCENT != -1 || $LOCALPERCENT != -1 || $DASHPERCENT !=- 1 );

die "-g value must be under 0 and 9 or * for 10 and . for 0\n"
   if !($GLOBALPERCENT eq "*" || $GLOBALPERCENT eq "."
     || $GLOBALPERCENT =~ m/^\d+$/ && $GLOBALPERCENT < 10 && $GLOBALPERCENT >= 0 );
   
die "-s value must be under 0 and 9 or * for 10 and . for 0\n" 
   if !($LOCALPERCENT eq "*" || $LOCALPERCENT eq "."
     || $LOCALPERCENT =~ m/^\d+$/ && $LOCALPERCENT < 10 && $LOCALPERCENT >= 0);

die "-d value must be under 0 and 100\n" 
   if !( $DASHPERCENT !~ m/^\d+$/ || $DASHPERCENT <= 100 && $DASHPERCENT >= 0);
     
###########################################
# Validate remaining command-line options #
###########################################

&Usage if @ARGV;

$INFILE  = "-" if $INFILE  eq "";
$OUTFILE = "-" if $OUTFILE eq "";

die "At least one of -f or -p must be specified.\n"
   unless $FORMAT || $PROGRAM;
die "Only one of -f or -p must be specified.\n"
   if $FORMAT && $PROGRAM;
die "When supplied, the argument to -S must be a number greater than 0.\n"
   if $STRUCTURES && $STRUCTURES !~ m#^[1-9]\d*$#;

if ($PROGRAM) {
   $FORMAT = $PROG_TO_FORMAT{$PROGRAM};
   die "Cannot find format to use for program '$PROGRAM'.\n"
       unless $FORMAT;
}

if (!$FORMAT_TO_PROGS{$FORMAT}) {
     foreach my $supported (keys %FORMAT_TO_PROGS) {
         next unless (lc $supported) eq (lc $FORMAT);
         $FORMAT = $supported;
         last;
     }
}

die "Error: format '$FORMAT' not supported.\n"
   unless $FORMAT_TO_PROGS{$FORMAT};

################
# Trap Signals #
################

sub SigCleanup { # private
     die "\nExiting: received signal \"" . $_[0] . "\".\n";
     # Note that some cleanup will be performed in the END block at this point.
}
$SIG{'INT'}  = \&SigCleanup;
$SIG{'TERM'} = \&SigCleanup;
$SIG{'HUP'}  = \&SigCleanup;
$SIG{'QUIT'} = \&SigCleanup;
$SIG{'PIPE'} = sub { exit 0; };

###############################
#   M A I N   P R O G R A M   #
###############################

# Read input file. This is a memory hungry slurp.
my $infh = new IO::File "<$INFILE" 
    or die "Cannot read from input file '$INFILE': $!\n";
my @inputtext = <$infh>; # slurp
$infh->close();

# Guess input format
my $inFormat = &GuessInputFormat(\@inputtext);
print STDERR "Your input file seems to be in '$inFormat' format.\n"
    if $VERBOSE;

# Read the multiple alignments into a standard internal structure.
my $content = &ParseInput(\@inputtext,$inFormat);
@inputtext = (); # Zap input array text, free memory

# Validate multiple alignments data (optional, with -c)
&ValidateMultAligns($content) if $VALIDATE;

# Write them back in the desired output format
my $outfh = new IO::File ">$OUTFILE"
    or die "Cannot write to output file '$OUTFILE': $!\n";
&DumpOutput($outfh,$content,$FORMAT);
$outfh->close();

exit 0;


END { 
    # With exit, programme will go here
    # Cleanup temp directory when program exits.
    return unless defined($TMPDIR) and $TMPDIR =~ m#^/tmp/#;
    rmtree($TMPDIR);
}

#############################
#   S U B R O U T I N E S   #
#############################

sub SeqCleanup {
    my $seqdata = shift;
    if ($KEEPALLCHARS) {
        $seqdata =~ s/\s+//g; # just remove blank spaces
    } else {
        $seqdata =~ tr/a-zA-Z\-*~.//cd; # MUST KEEP DASHES!
    }
    $seqdata;
}

sub ListKnownFormats {
    print "-----------------------------------------------------\n";
    print "List of known formats and the programs which use them\n";
    print "-----------------------------------------------------\n";
    print "\n";
    my @report = ();
    my $maxf = 0;
    my $maxd = 0;
    foreach my $format (sort keys %FORMAT_TO_PROGS) {
        my $long = $FORMAT_LONG{$format} || "";
        my $progs = $FORMAT_TO_PROGS{$format};
        my $proglist = join(", ",sort @$progs);
        $maxf = length($format) if length($format) > $maxf;
        $maxd = length($long)   if length($long)   > $maxd;
        push(@report,[ $format, $long, $proglist ] );
    }
    $maxf++; $maxd++;
    $maxf = 11 if $maxf < 11; # for length of 'Format (-f)'
    $maxd = 11 if $maxd < 11; # for length of 'Description'
    printf "%-${maxf}s  %-${maxd}s  %s\n","Format (-f)","Description","Programs (-p)";
    printf "%-${maxf}s  %-${maxd}s  %s\n","-----------","-----------","-------------";
    foreach my $line (@report) {
        my ($format,$long,$proglist) = @$line;
        printf "%-${maxf}s  %-${maxd}s  %s\n",$format,$long,$proglist;
    }
    print "\n";
}

sub GuessInputFormat {
    my $text = shift; # array with lines of text from input file, unchomped

    for (my $i=0; $i < @$text;$i++) {
        my $line = $text->[$i];
        next if $line =~ m#^\s*$#;

        if ($line =~ m/^#\s*STOCKHOLM/i) {
            return "STOCKHOLM";
        }

        if ($line =~ m#^\{\s*$#) {
            return "GDE";
        }

        if ($line =~ m#^CLUSTAL X#) {
            return "CLUSTAL"; # TODO params?
        }

        if ($line =~ m#^>#) {
            return "FASTA"; # TODO params?
        }

        if ($line =~ m/^\s*#\s*nexus/i) {
            return "NEXUS"; # TODO params?
        }

        if ($line =~ m#^\s*\d+\s+\d+#) {  # found phylip header
            my $next1 = $text->[$i+1] || "";
            my $next2 = $text->[$i+2] || "";
            if ($next1 =~ m#^(\S+)\s+(\S+)# && $next2 =~ m#^(\S+)\s+(\S+)#) {
                return "Phylip-I"; # TODO params?
            } else {
                return "Phylip-N"; # TODO params?
            }
        }

        last; # unknown?!?!
    }
    
    return "Unknown";
}

sub ParseInput {
    my $text   = shift;
    my $format = shift;

    my %InputSubroutines = (
        "FASTA"     => "ReadFastaMultAligns",
        "Phylip-N"  => "ReadPhylipNMultAligns",
        "Phylip-I"  => "ReadPhylipIMultAligns",
        "NEXUS"     => "ReadNexusMultAligns",
        "CLUSTAL"   => "ReadClustalMultAligns",
        "STOCKHOLM" => "ReadStockholmMultAligns",
    );

    my $sub = $InputSubroutines{$format}
        || die "Unsupported input format '$format'.\n";

    no strict 'refs';
    my $content = &$sub($text);
    $content;
}

sub DumpOutput {
    my $outfh   = shift;
    my $content = shift;
    my $format  = shift;

    my %OutputSubroutines = (
        "FASTA"     => "DumpFastaMultAligns",
        "Phylip-N"  => "DumpPhylipNMultAligns",
        "Phylip-I"  => "DumpPhylipIMultAligns",
        "NEXUS"     => "DumpNexusMultAligns",
        "CLUSTAL"   => "DumpClustalMultAligns",
        "GDE"       => "DumpGDEMultAligns",
        "RAW"       => "DumpRAWMultAligns",
        "STOCKHOLM" => "DumpStockholmMultAligns",
    );

    my $sub = $OutputSubroutines{$format}
        || die "Unsupported output format '$format'.\n";

    no strict 'refs';
    &$sub($outfh,$content);

}

sub ValidateMultAligns {
    my $content = shift;

    if (@$content == 0) {
        print STDERR "Error: your input file contains NO multiple alignments.\n";
        return;
    }

    my %numseqs=();
    my %seqlens=();

    for (my $i=0;$i<@$content;$i++) {
        my $ma   = $content->[$i];
        my $maid = $ma->alignId() || "#$i";
        my $seqlist = $ma->get_alignedSeqs() || [];

        if (@$seqlist == 0) {
            print STDERR "Error: the multiple alignment '$maid' contains NO sequences.\n";
            next;
        }

        my $numseq = @$seqlist;
        $numseqs{$numseq}++;
        my %localseqlens = ();
        foreach my $seqobj (@$seqlist) {
            my $id  = $seqobj->seqId()    || "Unknown";
            my $seq = $seqobj->sequence() || "";
            my $len = length($seq);
            $localseqlens{$len}++;
            $seq =~ tr/~\-ACDEFGHIKLMNPQRSTVWXYacdefghiklmnpqrstvwxy*//d;
            if ($seq ne "") {
                 print STDERR "Warning: in alignment '$maid', sequence '$id' contains some weird characters '$seq'.\n";
            }
        }
        if (scalar(keys %localseqlens) > 1) {
            print "Error: multiple alignment '$maid' contains sequence of different lengths:\n";
            foreach my $len (sort { $a <=> $b } keys %localseqlens) {
                print STDERR " -> ",$localseqlens{$len}, " sequences with length $len\n";
            }
        }

        while (my ($len,$cnt) = each %localseqlens) {
            $seqlens{$len} += $cnt;
        }

    }

    if (scalar(keys %seqlens) > 1) {
        print "Error: overall, your input file contains sequence of different lengths:\n";
        foreach my $len (sort { $a <=> $b } keys %seqlens) {
            print STDERR " -> ",$seqlens{$len}, " sequences with length $len\n";
        }
    }

    if (scalar(keys %numseqs) > 1) {
        print "Error: overall, your input file contains multiple alignments with different number of sequences each:\n";
        foreach my $num (sort { $a <=> $b } keys %numseqs) {
            print STDERR " -> ",$numseqs{$num}, " multiple alignments with $num sequences\n";
        }
    }

}



#######################################
# FASTA input/output
#######################################

sub ReadFastaMultAligns {
    my $text = shift;

    my $content = [];

    for (;;) {
        my @matext = ();
        my %seenids = ();

        while (@$text) {
            my $line = shift(@$text);
            next if $line =~ m#^\s*$|^\s*;#;
            if ($line =~ m#^>\s*(\S+)#) {
                my $id = $1;
                if ($seenids{$id}) {
                    unshift(@$text,$line);
                    last;
                }
                $seenids{$id}++;
            }
            push(@matext,$line);
        }
        last unless @matext;

        my $seqlist = [];
        my $seqobj  = undef;
        my $seq     = "";

        for (my $i = 0; $i < @matext; $i++) {
            my $line = $matext[$i];
            if ($line =~ m#^>\s*(\S+)(\s+.*\S)?\s*$#) {
                my ($newid,$rest) = ($1,$2);
                $rest = "" if !defined($rest);
                if ($seqobj) {
                    $seq = &SeqCleanup($seq);
                    $seqobj->set_sequence($seq);
                }
                $seq="";
                $seqobj = new PirObject::AlignedSeq(
                    seqId        => $newid,
                    seqFastaRest => $rest,
                    sequence     => "",
                );
                push(@$seqlist,$seqobj);
                next;
            }
            $seq .= $line;
        }

        if ($seqobj) { # handle last seq in file
             $seq = &SeqCleanup($seq);
             $seqobj->set_sequence($seq);
        }

        my $ma = new PirObject::MultAlign(
            alignedSeqs => $seqlist,
        );

        push(@$content,$ma);
    }

    $content;
}

sub DumpFastaMultAligns {
    my $fh      = shift;
    my $content = shift;

    foreach my $ma (@$content) {
        my $seqlist = $ma->get_alignedSeqs() || [];
        foreach my $seqobj (@$seqlist) {
            my $text = $seqobj->AsFasta();
            print $fh $text;
        }
    }

}



#######################################
# Phylip-N input/output
#######################################

sub ReadPhylipNMultAligns {
    my $text = shift;

    my $content = [];

    for (;;) {
        my @matext = ();
        shift(@$text) while @$text && $text->[0] =~ m#^\s*$#;
        my $sizeline = @$text ? shift(@$text) : "";  # size line
        push(@matext,shift(@$text)) while @$text && $text->[0] !~ m#^\s*\d+\s+\d+#;
        last unless @matext;

        die "Error: first line of Phylip multiple alignement is incorrect. Expected '<numseq> <seqlength>', got:\n$sizeline\n"
            unless $sizeline =~ m#^\s*([1-9]\d*)\s+([1-9]\d*)#;
        my ($numseq,$length) = ($1,$2);

        my $seqlist = [];
        my $seqobj  = undef;
        my $seq = "";

        for (my $i=0;$i < @matext;$i++) {
            my $line = $matext[$i];
            next if $line =~ m#^\s*$#;

            if (!$seqobj) {
                die "Can't parse line in Phylip alignment file: Line was:\n$line\n"
                    unless $line =~ s#^(\S+)\s*##;
                my $id = $1;
                $line = &SeqCleanup($line);
                $seqobj = new PirObject::AlignedSeq(
                    seqId    => $id,
                    sequence => $line,
                );
                $seq = $line;
                push(@$seqlist,$seqobj);
                $seqobj = undef if length($line) >= $length;
                next;
            }
            $line = &SeqCleanup($line);
            $seq .= $line;
            $seqobj->set_sequence($seq);
            $seqobj = undef if length($seq) >= $length;
        }

        my $ma = new PirObject::MultAlign(
            alignedSeqs => $seqlist,
        );

        push(@$content,$ma);
    }

    $content;
}

sub DumpPhylipNMultAligns {
    my $fh      = shift;
    my $content = shift;

    foreach my $ma (@$content) {
        my $numseq  = $ma->NumSequences();
        my $seqlen  = $ma->AlignmentLength();
        my $seqlist = $ma->get_alignedSeqs() || [];
        print $fh "$numseq\t$seqlen\n";
        foreach my $seqobj (@$seqlist) {
            my $text = $seqobj->AsPhylipN();
            print $fh $text;
        }
    }
}



#######################################
# Phylip-I input/output
#######################################

sub ReadPhylipIMultAligns {
    my $text = shift;

    my $content = [];

    for (;;) {
        my @matext = ();
        shift(@$text) while @$text && $text->[0] =~ m#^\s*$#;
        my $sizeline = @$text ? shift(@$text) : "";  # size line
        push(@matext,shift(@$text)) while @$text && $text->[0] !~ m#^\s*\d+\s+\d+#;
        last unless @matext;

        die "Error: first line of Phylip multiple alignement is incorrect. Expected '<numseq> <seqlength>', got:\n$sizeline\n"
            unless $sizeline =~ m#^\s*([1-9]\d*)\s+([1-9]\d*)#;
        my ($numseq,$length) = ($1,$2);

        my $seqlist = [];
        my $seqobj  = undef;
        my $seq = "";

        shift(@matext) while @matext && $matext[0] =~ m#^\s*$#;
        my $reachedlen = 0;
        while (@matext) {
            for (my $i=0;$i<$numseq;$i++) {
                shift(@matext) while @matext && $matext[0] =~ m#^\s*$#;
                last unless @matext;
                my $line = shift(@matext);
                if (!defined($seqlist->[$i])) {
                    my ($id,$seq) = ($line =~ m#^(\S+)(.*)#);
                    $line = $seq;
                    $seqlist->[$i] = PirObject::AlignedSeq->new(
                        seqId    => $id,
                        sequence => "",
                    );
                }
                $line = &SeqCleanup($line);
                my $seqobj = $seqlist->[$i];
                my $seq    = $seqobj->get_sequence() || "";
                $seq .= $line;
                $seqobj->set_sequence($seq);
                $reachedlen++ if length($seq) >= $length;
            }
            last if $reachedlen; # TODO check that ALL $numseq seqs have reached $length
        }

        my $ma = new PirObject::MultAlign(
            alignedSeqs => $seqlist,
        );

        push(@$content,$ma);
    }

    $content;
}

sub DumpPhylipIMultAligns {
    my $fh      = shift;
    my $content = shift;

    foreach my $ma (@$content) {
        my $numseq  = $ma->NumSequences();
        my $seqlen  = $ma->AlignmentLength();
        my $seqlist = $ma->get_alignedSeqs() || [];
        print $fh "$numseq\t$seqlen\n";
        for (my $i=0;$i < $seqlen;$i += 50) {
            foreach my $seqobj (@$seqlist) {
                my $seq = $seqobj->get_sequence();
                my $remain = length($seq) - $i;
                if ($remain <= 0) { # should never happen
                    print $fh ((" " x 13),"\n");
                    next;
                }
                my $subseq = substr($seq,$i, $remain < 50 ? $remain : 50);
                foreach my $space ( 40, 30, 20, 10 ) {
                    next if $space >= length($subseq);
                    substr($subseq,$space,0) = " ";
                }
                if ($i == 0) {
                    my $id = $seqobj->get_seqId() || "Unknown";
                    $id = substr($id,0,10) if length($id) > 10;
                    $id .= " " while length($id) < 13;
                    print $fh $id,$subseq,"\n";
                } else {
                    print $fh ((" " x 13),$subseq,"\n");
                }
            }
            print $fh "\n";
        }
    }
}



#######################################
# NEXUS input/output
#######################################

sub ReadNexusMultAligns {
    my $text = shift;

    my $content = [];

    for (;;) {
        my @matext = ();
        shift(@$text) while @$text && $text->[0] =~ m#^\s*$#;
        my $nexusline = @$text ? shift(@$text) : "";  # nexus line
        push(@matext,shift(@$text)) while @$text && $text->[0] !~ m/\s*#\s*nexus/i;
        @matext = grep(!m#\s*\[|^\s*$#,@matext);
        last unless @matext;

        die "Error: expected #NEXUS line, got '$nexusline'.\n"
            unless $nexusline =~ m/^\s*#\s*nexus/i;

        my ($numseq,$length) = (0,0);
        while (@matext) {
            my $line = shift @matext;
            last if $line =~ m#^\s*matrix#i;
            next if $line =~ m#begin data#i;
            if ($line =~ m#dimensions\s+ntax=(\d+)\s+nchar=(\d+)#) {
                ($numseq,$length) = ($1,$2);
                next;
            }
            if ($line =~ m#^\s*format#) {
               #format datatype=protein interleave missing=-
               die "Error: cannot parse NEXUS format that is not interleaved.\n"
                   unless $line =~ m#\sinterleave#i;
               # TODO parse other format options?
               next;
            }
            die "Unrecognized NEXUS format line: $line\n";
        }

        die "Could not found ntax and nchar in NEXUS file?!?\n"
            unless $numseq > 0 && $length > 0;

        my $seqlist = [];
        my $seqobj  = undef;
        my $seq = "";

        my $reachedlen = 0;
        while (@matext) {
            for (my $i=0;$i<$numseq;$i++) {
                shift(@matext) while @matext && $matext[0] =~ m#^\s*$#;
                last unless @matext;
                my $line = shift(@matext);
                my ($id,$seq) = ($line =~ m#^\s*(\S+)(.*)#);
                if (!defined($seqlist->[$i])) {
                    $seqlist->[$i] = PirObject::AlignedSeq->new(
                        seqId    => $id,
                        sequence => "",
                    );
                } else {
                    my $curid = $seqlist->[$i]->get_seqId();
                    die "Inconsistency in NEXUS format, got seq line for '$id' expecting one for '$curid'.\n"
                        unless $curid eq $id;
                }
                $seq = &SeqCleanup($seq);
                my $seqobj = $seqlist->[$i];
                my $curseq = $seqobj->get_sequence() || "";
                $curseq .= $seq;
                $seqobj->set_sequence($curseq);
                $reachedlen++ if length($curseq) >= $length;
            }
            last if $reachedlen; # TODO check that ALL $numseq seqs have reached $length
        }

        my $ma = new PirObject::MultAlign(
            alignedSeqs => $seqlist,
        );

        push(@$content,$ma);
    }

    $content;
}

sub DumpNexusMultAligns {
    my $fh      = shift;
    my $content = shift;

    foreach my $ma (@$content) {
        my $numseq  = $ma->NumSequences();
        my $seqlen  = $ma->AlignmentLength();
        my $seqlist = $ma->get_alignedSeqs() || [];
        my $type    = $ma->GuessType() || "Unknown";
        print $fh "#NEXUS\n",
                  "begin data;\n",
                  " dimensions ntax=$numseq nchar=$seqlen;\n",
                  " format datatype=$type interleave missing=-;\n",
                  "  matrix\n";

        for (my $i=0;$i < $seqlen;$i += 100) {
            foreach my $seqobj (@$seqlist) {
                my $seq = $seqobj->get_sequence();
                my $remain = length($seq) - $i;
                if ($remain <= 0) { # should never happen
                    print $fh ((" " x 11),"\n");
                    next;
                }
                my $subseq = substr($seq,$i, $remain < 100 ? $remain : 100);
                foreach my $space ( 80, 60, 40, 20 ) {
                    next if $space >= length($subseq);
                    substr($subseq,$space,0) = " ";
                }
                my $id = $seqobj->get_seqId() || "Unknown";
                $id = substr($id,0,9) if length($id) > 9;
                $id = " $id" while length($id) < 9;
                print $fh $id,"  ",$subseq,"\n";
            }
            print $fh "\n";
        }

        print $fh ";\n",
                  "  end;\n";

    }
}



#######################################
# CLUSTAL input/output
#######################################

sub ReadClustalMultAligns {
    my $text = shift;

    my $content = [];

    for (;;) {
        my @matext = ();
        shift(@$text) while @$text && $text->[0] =~ m#^\s*$#;
        my $headerline = @$text ? shift(@$text) : "";  # constant "CLUSTAL X"
        push(@matext,shift(@$text)) while @$text && $text->[0] !~ m#^CLUSTAL X#;
        last unless @matext;

        die "Error: first line of Clustal multiple alignement is incorrect. Expected 'CLUSTAL X', got:\n$headerline\n"
            unless $headerline =~ m#^CLUSTAL X#;
        my ($numseq,$length) = (0,0);

        my $seqlist = [];
        my $seqobj  = undef;
        my $seq = "";

#Coccidoides.pos               ACACTCGTGCGAGCAATCCACGAACGG-CTG-----------TGGCGCGC

        shift(@matext) while @matext && $matext[0] =~ m#^\s*$#;
        while (@matext) {
            for (my $i=0;;$i++) {
                last unless @matext;
                last if @matext && $matext[0] =~ m#^\s*$#;
                my $line = shift(@matext);
                my ($id,$rest) = ($line =~ m#^(.{30,30})(\S+)#);
                if (!defined($seqlist->[$i])) {
                    $id =~ s/\s*$//;
                    $seqlist->[$i] = PirObject::AlignedSeq->new(
                        seqId    => $id,
                        sequence => "",
                    );
                }
                $rest = &SeqCleanup($rest);
                my $seqobj = $seqlist->[$i];
                my $seq    = $seqobj->get_sequence() || "";
                $seq .= $rest;
                $seqobj->set_sequence($seq);
            }
            shift(@matext) while @matext && $matext[0] =~ m#^\s*$#
        }

        my $ma = new PirObject::MultAlign(
            alignedSeqs => $seqlist,
        );

        push(@$content,$ma);
    }

    $content;
}

sub DumpClustalMultAligns {
    my $fh      = shift;
    my $content = shift;

    foreach my $ma (@$content) {
        my $numseq  = $ma->NumSequences();
        my $seqlen  = $ma->AlignmentLength();
        my $seqlist = $ma->get_alignedSeqs() || [];
        print $fh "CLUSTAL X\n\n";
        for (my $i=0;$i < $seqlen;$i += 50) {
            print $fh "\n";
            foreach my $seqobj (@$seqlist) {
                my $seq = $seqobj->get_sequence();
                my $remain = length($seq) - $i;
                if ($remain <= 0) { # should never happen
                    die "Internal error clustal W\n";
                }
                my $subseq = substr($seq,$i, $remain < 50 ? $remain : 50);
                my $id = $seqobj->get_seqId() || "Unknown";
                $id = substr($id,0,29) if length($id) > 29;
                $id .= " " while length($id) < 29;
                print $fh $id," ",$subseq,"\n";
            }
            print $fh "\n";
        }
    }
}



#######################################
# GDE input/output
#######################################

sub ReadGDEMultAligns {
    my $text = shift;

    die "GDE input not supported yet.\n";
}

sub DumpGDEMultAligns {
    my $fh      = shift;
    my $content = shift;

    foreach my $ma (@$content) {  # TODO: cannot differentiate between multiple multaligns
        my $numseq  = $ma->NumSequences();
        my $seqlen  = $ma->AlignmentLength();
        my $seqlist = $ma->get_alignedSeqs() || [];

        foreach my $seqobj (@$seqlist) {
            my $seq   = $seqobj->get_sequence();
            my $id    = $seqobj->get_seqId()        || "Unknown";
            my $rest  = $seqobj->get_seqFastaRest() || "";

            my $seqlet = $seq; $seqlet =~ tr/a-zA-Z//cd; # not SeqCleanup!
            my $acgtn = ($seqlet =~ tr/acgtnACGTN/acgtnACGTN/);
            my $type  = ($acgtn > .8 * length($seqlet) ? "DNA" : "PROTEIN");

            my $prettyseq = "";
            $seq =~ tr/~/-/;
            for (my $i=0;$i < length($seq);$i += 50) {
                my $len = length($seq) - $i; $len = 50 if $len > 50;
                $prettyseq .= substr($seq,$i,$len) . "\n";
            }
            print $fh <<GDERECORD;
{
name        "$id"
type        "$type"
descrip     "$rest"
sequence    "
$prettyseq"
}
GDERECORD
        }
    }
}



#######################################
# RAW format input/output
#######################################

sub ReadRAWMultAligns {
    my $text = shift;

    die "RAW input not supported yet.\n";
}

sub DumpRAWMultAligns {
    my $fh      = shift;
    my $content = shift;

    foreach my $ma (@$content) {  # TODO: cannot differentiate between multiple multaligns
        my $numseq  = $ma->NumSequences();
        my $seqlen  = $ma->AlignmentLength();
        my $seqlist = $ma->get_alignedSeqs() || [];

        foreach my $seqobj (@$seqlist) {
            my $seq   = $seqobj->get_sequence();
            #my $id    = $seqobj->get_seqId()        || "Unknown";
            #my $rest  = $seqobj->get_seqFastaRest() || "";

            print $seq,"\n";
        }
    }
}

#######################################
# STOCKHOLM format input/output
#######################################

sub ReadStockholmMultAligns {
    my $content = [];
    
    # Read input file. This is a memory hungry slurp.
    my $alifh = new IO::File "<$INFILE" 
        or die "Cannot read from input file '$INFILE': $!\n";
    my $text = [<$alifh>]; # slurp
    $alifh->close();
    
    # Separate all block 
    my $each_block = {};
    my $block      = ();
    my $i          = 0;
    while (@$text) {
        my $line   = shift(@$text);
        my $isLast = 1 if scalar(@$text) == 0;
        if ($line !~ m/^\n$/ && !$isLast) {
            push(@$block,$line);
        }
        else {
            $each_block->{$i} = $block;
            $block = ();
            $i++;
        }
    }
    
    # Treat block by block.
    my %global_seenids    = ();
    my $nb_block_with_seq = 0;
    my $info              = {};
    my $seqlist           = [];
    my $seqobj            = undef;
    my ($PP_cons,$RF)     = ("","");
    
    foreach my $key (sort (keys(%$each_block))) {
        $block  = $each_block->{$key};
        my $nb_seq = 0;
        my %seenids = ();
        for (my $i = 0; $i < @$block; $i++) {
            my $line = $block->[$i];
            #Treat #=GC
            if ($line =~ m/#=GC\s*/) {
                my @split = split(/\s+/, $line);
                $PP_cons .= $split[-1] if $line =~ m/PP_cons/;
                $RF      .= $split[-1] if $line =~ m/RF/;
            }
            
            # Treat sequence 
            next if $line =~ m/^#/;
            my @split_line  = split(/\s+/, $line);
            my ($name,$seq) = @split_line;
            my $id = $name && $name =~ m/(.+)\// ? $1 : $name;
            $nb_seq++;
            $seenids{$id}++;
            $global_seenids{$id}++;
            
            my $begin_seq = $info->{$id}->{$seenids{$id}}->{seq};
            $seq = defined($begin_seq) ? "${begin_seq}$seq": $seq;
            $info->{$id}->{$seenids{$id}}->{seq} = $seq;

            # Treat #GR if next $line =~ m/^#=GR/
            my $next_line       = $block->[$i+1];
            next if !$next_line;
            next if $next_line  !~ m/^#=GR/;
            my @split_next_line = split(/\s+/, $next_line);
            my ($tag,$name_next,$feat,$mark)  = @split_next_line;
            my $id_next = $name_next && $name_next =~ m/(.+)\// ? $1 : $name_next;
            print "$name doesn't match with #=GR PP line\n" if $id_next ne $id;
            next if $feat ne "PP";
            my $begin_PP = $info->{$id}->{$seenids{$id}}->{PP};
            my $PP = defined($begin_PP) ? "${begin_PP}$mark": $mark;
            $info->{$id}->{$seenids{$id}}->{PP} = $PP;
        }
        $nb_block_with_seq++ if $nb_seq != 0;
    }

    while ( my ($id, $value) = each(%global_seenids) ) { 
          my $mod   = $value % $nb_block_with_seq;
          die "Sequence $id not present in all block\n" if $mod != 0;
    }
    
    my $length_stand = 0;
    for my $id ( keys %$info ) {
        my $info_for_id = $info->{$id};
        my $nb_dupli    = scalar( keys %$info_for_id);

        for my $num_dupli ( keys %$info_for_id ) {
            my $info_for_dupli = $info_for_id->{$num_dupli};
            my $id  = $nb_dupli == 1 ? $id : "${num_dupli}${id}";
            my $seq = $info_for_dupli->{seq};
            my $PP  = $info_for_dupli->{PP};
            my $length_PP    = length($PP) if $PP;
            my $length_seq   = length($seq);
            $length_stand = $length_seq if $length_stand == 0;
            die "PP and sequence haven't same length for $id\n" 
                if $PP && $length_PP != $length_seq;
            die "$id haven't standard length\n" 
                if $length_seq != $length_stand;
            $seqobj = new PirObject::AlignedSeq(
                seqId        => $id,
                sequence     => $seq,
                PP           => $PP,
            );
            push(@$seqlist,$seqobj);
        }
    }
    my $length_PP_cons  = length($PP_cons);
    die "PP_cons haven't standard length\n"
        if $length_PP_cons && $length_PP_cons != $length_stand;
    
    $text = []; # Zap input array text, free memory
            
    my $ma = new PirObject::MultAlign(
        alignedSeqs => $seqlist,
        PP_cons     => $PP_cons,
    );
    push(@$content,$ma);
    
    &FilteringStockholm($ma) if $FILTERING == 1;
    
    return $content;
}

sub FilteringStockholm {
    my $ma = shift;
    
    my $PP_cons     = $ma->get_PP_cons();
    die "Can't use option -F no line 'PP_cons' found in $INFILE\n" 
        if $PP_cons eq "";
    my $alignedSeqs = $ma->get_alignedSeqs();

    #Make array with pos to remove use GLOBALPERCENT
    my $GlobalPercent = $GLOBALPERCENT;
       $GlobalPercent = 10 if $GLOBALPERCENT eq "*";
       $GlobalPercent = 0  if $GLOBALPERCENT eq ".";
       
    my $columnToRemove = ();

    for ( my $i = 0 ; $i < length($PP_cons) ; $i++) {
        my $PP_val = substr($PP_cons,$i,1);
        $PP_val    =  0 if $PP_val eq ".";
        $PP_val    = 10 if $PP_val eq "*";
        push(@$columnToRemove,$i) if $PP_val < $GlobalPercent;
    }
    
    #Treat each Seq with LOCALPERCENT and GLOBALPERCENT
    my $LocalPercent = $LOCALPERCENT;
       $LocalPercent = 10 if $LOCALPERCENT eq "*";
       $LocalPercent = 0  if $LOCALPERCENT eq ".";
    my %cols_to_remove = map { $_ => 1 } @$columnToRemove;
    foreach my $alignedSeq (@$alignedSeqs) {
        my $PP  = $alignedSeq->get_PP();
        my $Seq = $alignedSeq->get_sequence();
        #Treat LOCALPERCENT
        for (my $i = length($Seq) - 1; $i >= 0 ; $i--) {
            my $PP_val = substr($PP,$i,1);
            $PP_val    =  0  if $PP_val eq ".";
            $PP_val    = 10  if $PP_val eq "*";
            substr($Seq,$i,1) = "-" if $PP_val < $LocalPercent;
            substr($Seq,$i,1) = ""  if $cols_to_remove{$i};
        }
        $alignedSeq->set_sequence($Seq);
    }

    #Treat Dash    
    # Make array nb of dash foreach pos
    my $Dash = ();
    my $DashPercent  = $DASHPERCENT;
    foreach my $alignedSeq (@$alignedSeqs) {
        my $Seq = $alignedSeq->get_sequence();
        # Treat DASHPERCENT
        for ( my $i = 0 ; $i < length($Seq) ; $i++) {
            my $val = $Dash->[$i] || 0;
            my $aa = substr($Seq,$i,1);
            $val++ if $aa eq "-";
            $Dash->[$i] = $val;
        }
    }

    #Make array with pos to remove use DASHPERCENT
    my $nb_seq = scalar(@$alignedSeqs);
    my $Dash_Percent = $DASHPERCENT;
    $columnToRemove = ();
    for ( my $i = 0 ; $i < @$Dash ; $i++) {
        my $val     = $Dash->[$i];
        my $Dash_per = 100 - ($val*100)/$nb_seq;
        push(@$columnToRemove,$i) if $Dash_per <= $DashPercent;
    }
    
    #Remove dash percent
    %cols_to_remove = ();
    %cols_to_remove = map { $_ => 1 } @$columnToRemove;
    foreach my $alignedSeq (@$alignedSeqs) {
        my $Seq = $alignedSeq->get_sequence();
        #Treat DASHPERCENT
        for (my $i = length($Seq) - 1; $i >= 0 ; $i--) {
            substr($Seq,$i,1) = ""  if $cols_to_remove{$i};
        }
        $alignedSeq->set_sequence($Seq);
    }
}

sub DumpStockholmMultAligns {
    my $fh      = shift;
    my $content = shift;

    my $namelen = 23;
    my $maxlen = 100;

    foreach my $ma (@$content) {
        my $numseq  = $ma->NumSequences();
        my $seqlen  = $ma->AlignmentLength();
        my $seqlist = $ma->get_alignedSeqs() || [];

        # Move 'structure' sequences to the end of the list
        for (my $c = 0; $c < $STRUCTURES;$c++) {
            my $structobj = shift @$seqlist;
            my $structseq = $structobj->get_sequence() || "";

            my $seq = &TransformIntoStockholmStruct($structseq);
            $structobj->set_sequence($seq);
            $structobj->set_seqId("#=GC SS_cons");
            push(@$seqlist,$structobj);

            my $maskobj = new PirObject::AlignedSeq(
                seqId        => "#=GC RF",
                sequence     => $structseq,  # as is
            );
            push(@$seqlist, $maskobj);
        }

        print $fh "# STOCKHOLM 1.0\n";

        for (my $i=0;$i < $seqlen;$i += $maxlen) {
            print $fh "\n";
            for (my $s=0; $s < @$seqlist;$s++) {
                my $seqobj = $seqlist->[$s];
                my $seq = $seqobj->get_sequence();
                my $remain = length($seq) - $i;
                $remain = 0 if ($remain <= 0);
                my $subseq = substr($seq,$i, $remain < $maxlen ? $remain : $maxlen);
                my $id = $seqobj->get_seqId() || "Unknown";
                $id = substr($id,0,$namelen) if length($id) > $namelen;
                $id .= " " while length($id) < $namelen;
                print $fh $id," ",$subseq,"\n";
            }
        }

        print $fh "//\n";
    }
}

sub TransformIntoStockholmStruct {
    my $seq = shift;
    my %seenUppercasePos=();
    my @seq = split(m//,$seq);
    for (my $pos=0;$pos < @seq;$pos++) {
        my $c = $seq[$pos];
        if ($c !~ m#^[A-Z]$#) {
            $seq[$pos]=".";
            next;
        }
        if (!exists($seenUppercasePos{$c})) {
            $seq[$pos]="<";
        } elsif ($seenUppercasePos{$c} == $pos-1) {
            $seq[$pos]=$seq[$pos-1];
        } else {
            $seq[$pos]=">";
        }
        $seenUppercasePos{$c}=$pos;
    }
    join("",@seq);
}
