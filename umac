#!/usr/bin/perl -w -- -*-Perl-*-

##############################################################################
#
#                                 umac
#
# DESCRIPTION:
# Ultimate Multiple Alignment Converter
#
##############################################################################

##############################################################################
#
#    $Id: umac,v 1.9 2007/04/30 16:37:32 riouxp Exp $
#
#    $Log: umac,v $
#    Revision 1.9  2007/04/30 16:37:32  riouxp
#    Added support for #GC RF line in stockholm format.
#
#    Revision 1.8  2007/04/27 18:12:12  riouxp
#    Added preliminary support for Stockholm format (output only)
#    with a single structure line (#=GC SS_cons).
#
#    Revision 1.7  2007/04/20 17:02:12  riouxp
#    Added RAW format (output only).
#
#    Revision 1.6  2007/04/19 19:16:19  riouxp
#    Added option -K to make all non-blank characters significant in
#    alignments.
#
#    Revision 1.5  2007/04/18 18:24:37  riouxp
#    Added support for GDE format (output only for the moment).
#
#    Revision 1.4  2007/04/16 16:49:05  riouxp
#    Added support for CLUSTAL format.
#
#    Revision 1.3  2007/02/21 20:55:28  hourlier
#    Added one blank line as an example.
#
#    Revision 1.2  2006/11/29 21:54:43  riouxp
#    Fixed list of progs/formats.
#
#    Revision 1.1  2006/11/28 16:33:35  riouxp
#    Newly checked-in.
#

##########################
# Initialization section #
##########################

require 5.00;
use strict;
use vars qw( $VERSION $RCS_VERSION $DEBUG );
use PirObject qw( MultAlign );
use IO::File;
use IO::Dir;

# Default umask
umask 027;

# Program's name and version number.
$RCS_VERSION='$Id: umac,v 1.9 2007/04/30 16:37:32 riouxp Exp $';
($VERSION) = ($RCS_VERSION =~ m#,v ([\w\.]+)#);
my ($BASENAME) = ($0 =~ /([^\/]+)$/);

# Get login name.
my $USER=getpwuid($<) || getlogin || die "Can't find USER from environment!\n";

##################################
# Global variables and constants #
##################################

$|=1;
$DEBUG=0;

# Arguments from command-line
my $INFILE="";
my $OUTFILE="";
my $FORMAT="";
my $PROGRAM="";
my $VERBOSE=0;
my $VALIDATE=0;
my $KEEPALLCHARS=0;
my $STRUCTURES=0;

# Long decription of each format's short keyword
my %FORMAT_LONG = (
    "Phylip-N"  => "Phylip non-interleaved",
    "Phylip-I"  => "Phylip interleaved",
    "FASTA"     => "FASTA (Pearson)",
    "NEXUS"     => "NEXUS (Paup)",
    "CLUSTAL"   => "Clustal W (interleaved)",
    "GDE"       => "GDE",
    "RAW"       => "Raw (one line per seq)",
    "STOCKHOLM" => "Stockholm (interleaved)",
);

my %PROG_TO_FORMAT = (
    "pb"       => "Phylip-N",
    "RAxMLHPC" => "Phylip-I",
    "IQPNNI"   => "Phylip-I",
    "jknife"   => "FASTA",
    "phyms"    => "FASTA",
    "paup"     => "NEXUS",
    "clustalw" => "CLUSTAL",
    "gde"      => "GDE",
    "RNAfold"  => "RAW",
    "hmmer"    => "STOCKHOLM",
    "infernal" => "STOCKHOLM",
);

my %FORMAT_TO_PROGS = ();
foreach my $prog (keys %PROG_TO_FORMAT) {
    my $format = $PROG_TO_FORMAT{$prog};
    $FORMAT_TO_PROGS{$format} ||= [];
    push(@{$FORMAT_TO_PROGS{$format}},$prog);
}

#####################################
# Command-Line Arguments Processing #
#####################################

sub Usage {
    print "This is $BASENAME $VERSION\n",
          "\n",
          "Usage: $BASENAME [-@[n]] [-v] [-c] [-K] [-S #] [-f format|-p program] [-i infile] [-o outfile]\n",
          "\n",
          "   -i is the input file, containing one or many multiple alignments\n",
          "   -o is the output file, converted\n",
          "   -f is the output format\n",
          "   -p is an alternative to -f, where you specify which external program\n",
          "      will use this output; the -f format will be selected for you\n",
          "   -v makes the program more verbose\n",
          "   -c tells the program to check the alignments for errors/inconsistencies\n",
          "   -K tells the program to allow any and all non blank characters in sequence data\n",
          "   -S # indicates that the first # sequences are structure descriptions\n",
          "\n",
          "Leaving -i and/or -o blank or supplying a single '-' can be used\n",
          "to mean STDIN or STDOUT for the files.\n",
          "\n";
    &ListKnownFormats();
    exit 20;
}

&Usage if @ARGV == 0;

for (;@ARGV;) {
    my ($opt,$arg) = ($ARGV[0] =~ /^-([\@iofpvcKS])(.*)$/o);
    last if ! defined $opt;
    if ($opt =~ /[iofpS]/ && $arg eq "") {
        if (@ARGV < 2) {
            print "Argument required for switch \"-$opt\".\n";
            exit 1;
        }
        shift @ARGV;
        $arg=$ARGV[0];
    }

    $DEBUG=(defined($arg) ? $arg : 1)             if $opt eq '@';

    $INFILE=$arg                                  if $opt eq 'i';
    $OUTFILE=$arg                                 if $opt eq 'o';
    $FORMAT=$arg                                  if $opt eq 'f';
    $PROGRAM=$arg                                 if $opt eq 'p';
    $VERBOSE++                                    if $opt eq 'v';
    $VALIDATE=1                                   if $opt eq 'c';
    $KEEPALLCHARS=1                               if $opt eq 'K';
    $STRUCTURES=$arg                              if $opt eq 'S';

    shift @ARGV;
}

###########################################
# Validate remaining command-line options #
###########################################

&Usage if @ARGV;

$INFILE  = "-" if $INFILE  eq "";
$OUTFILE = "-" if $OUTFILE eq "";

die "At least one of -f or -p must be specified.\n"
   unless $FORMAT || $PROGRAM;
die "Only one of -f or -p must be specified.\n"
   if $FORMAT && $PROGRAM;
die "When supplied, the argument to -S must be a number greater than 0.\n"
   if $STRUCTURES && $STRUCTURES !~ m#^[1-9]\d*$#;

if ($PROGRAM) {
   $FORMAT = $PROG_TO_FORMAT{$PROGRAM};
   die "Cannot find format to use for program '$PROGRAM'.\n"
       unless $FORMAT;
}

if (!$FORMAT_TO_PROGS{$FORMAT}) {
     foreach my $supported (keys %FORMAT_TO_PROGS) {
         next unless (lc $supported) eq (lc $FORMAT);
         $FORMAT = $supported;
         last;
     }
}

die "Error: format '$FORMAT' not supported.\n"
   unless $FORMAT_TO_PROGS{$FORMAT};

################
# Trap Signals #
################

sub SigCleanup { # private
     die "\nExiting: received signal \"" . $_[0] . "\".\n";
     # Note that some cleanup will be performed in the END block at this point.
}
$SIG{'INT'}  = \&SigCleanup;
$SIG{'TERM'} = \&SigCleanup;
$SIG{'HUP'}  = \&SigCleanup;
$SIG{'QUIT'} = \&SigCleanup;
$SIG{'PIPE'} = sub { exit 0; };

###############################
#   M A I N   P R O G R A M   #
###############################

# Read input file. This is a memory hungry slurp.
my $infh = new IO::File "<$INFILE" 
    or die "Cannot read from input file '$INFILE': $!\n";
my @inputtext = <$infh>; # slurp
$infh->close();

# Guess input format
my $inFormat = &GuessInputFormat(\@inputtext);
print STDERR "Your input file seems to be in '$inFormat' format.\n"
    if $VERBOSE;

# Read the multiple alignments into a standard internal structure.
my $content = &ParseInput(\@inputtext,$inFormat);
@inputtext = (); # Zap input array text, free memory

# Validate multiple alignments data (optional, with -c)
&ValidateMultAligns($content) if $VALIDATE;

# Write them back in the desired output format
my $outfh = new IO::File ">$OUTFILE"
    or die "Cannot write to output file '$OUTFILE': $!\n";
&DumpOutput($outfh,$content,$FORMAT);
$outfh->close();

exit 0;

#############################
#   S U B R O U T I N E S   #
#############################

sub SeqCleanup {
    my $seqdata = shift;
    if ($KEEPALLCHARS) {
        $seqdata =~ s/\s+//g; # just remove blank spaces
    } else {
        $seqdata =~ tr/a-zA-Z\-*~.//cd; # MUST KEEP DASHES!
    }
    $seqdata;
}

sub ListKnownFormats {
    print "-----------------------------------------------------\n";
    print "List of known formats and the programs which use them\n";
    print "-----------------------------------------------------\n";
    print "\n";
    my @report = ();
    my $maxf = 0;
    my $maxd = 0;
    foreach my $format (sort keys %FORMAT_TO_PROGS) {
        my $long = $FORMAT_LONG{$format} || "";
        my $progs = $FORMAT_TO_PROGS{$format};
        my $proglist = join(", ",sort @$progs);
        $maxf = length($format) if length($format) > $maxf;
        $maxd = length($long)   if length($long)   > $maxd;
        push(@report,[ $format, $long, $proglist ] );
    }
    $maxf++; $maxd++;
    $maxf = 11 if $maxf < 11; # for length of 'Format (-f)'
    $maxd = 11 if $maxd < 11; # for length of 'Description'
    printf "%-${maxf}s  %-${maxd}s  %s\n","Format (-f)","Description","Programs (-p)";
    printf "%-${maxf}s  %-${maxd}s  %s\n","-----------","-----------","-------------";
    foreach my $line (@report) {
        my ($format,$long,$proglist) = @$line;
        printf "%-${maxf}s  %-${maxd}s  %s\n",$format,$long,$proglist;
    }
    print "\n";
}

sub GuessInputFormat {
    my $text = shift; # array with lines of text from input file, unchomped

    for (my $i=0; $i < @$text;$i++) {
        my $line = $text->[$i];
        next if $line =~ m#^\s*$#;

        if ($line =~ m/^#\s*STOCKHOLM/i) {
            return "STOCKHOLM";
        }

        if ($line =~ m#^\{\s*$#) {
            return "GDE";
        }

        if ($line =~ m#^CLUSTAL X#) {
            return "CLUSTAL"; # TODO params?
        }

        if ($line =~ m#^>#) {
            return "FASTA"; # TODO params?
        }

        if ($line =~ m/^\s*#\s*nexus/i) {
            return "NEXUS"; # TODO params?
        }

        if ($line =~ m#^\s*\d+\s+\d+#) {  # found phylip header
            my $next1 = $text->[$i+1] || "";
            my $next2 = $text->[$i+2] || "";
            if ($next1 =~ m#^(\S+)\s+(\S+)# && $next2 =~ m#^(\S+)\s+(\S+)#) {
                return "Phylip-I"; # TODO params?
            } else {
                return "Phylip-N"; # TODO params?
            }
        }

        last; # unknown?!?!
    }
    
    return "Unknown";
}

sub ParseInput {
    my $text   = shift;
    my $format = shift;

    my %InputSubroutines = (
        "FASTA"     => "ReadFastaMultAligns",
        "Phylip-N"  => "ReadPhylipNMultAligns",
        "Phylip-I"  => "ReadPhylipIMultAligns",
        "NEXUS"     => "ReadNexusMultAligns",
        "CLUSTAL"   => "ReadClustalMultAligns",
    );

    my $sub = $InputSubroutines{$format}
        || die "Unsupported input format '$format'.\n";

    no strict 'refs';
    my $content = &$sub($text);
    $content;
}

sub DumpOutput {
    my $outfh   = shift;
    my $content = shift;
    my $format  = shift;

    my %OutputSubroutines = (
        "FASTA"     => "DumpFastaMultAligns",
        "Phylip-N"  => "DumpPhylipNMultAligns",
        "Phylip-I"  => "DumpPhylipIMultAligns",
        "NEXUS"     => "DumpNexusMultAligns",
        "CLUSTAL"   => "DumpClustalMultAligns",
        "GDE"       => "DumpGDEMultAligns",
        "RAW"       => "DumpRAWMultAligns",
        "STOCKHOLM" => "DumpStockholmMultAligns",
    );

    my $sub = $OutputSubroutines{$format}
        || die "Unsupported output format '$format'.\n";

    no strict 'refs';
    &$sub($outfh,$content);

}

sub ValidateMultAligns {
    my $content = shift;

    if (@$content == 0) {
        print STDERR "Error: your input file contains NO multiple alignments.\n";
        return;
    }

    my %numseqs=();
    my %seqlens=();

    for (my $i=0;$i<@$content;$i++) {
        my $ma   = $content->[$i];
        my $maid = $ma->alignId() || "#$i";
        my $seqlist = $ma->get_alignedSeqs() || [];

        if (@$seqlist == 0) {
            print STDERR "Error: the multiple alignment '$maid' contains NO sequences.\n";
            next;
        }

        my $numseq = @$seqlist;
        $numseqs{$numseq}++;
        my %localseqlens = ();
        foreach my $seqobj (@$seqlist) {
            my $id  = $seqobj->seqId()    || "Unknown";
            my $seq = $seqobj->sequence() || "";
            my $len = length($seq);
            $localseqlens{$len}++;
            $seq =~ tr/~\-ACDEFGHIKLMNPQRSTVWXYacdefghiklmnpqrstvwxy*//d;
            if ($seq ne "") {
                 print STDERR "Warning: in alignment '$maid', sequence '$id' contains some weird characters '$seq'.\n";
            }
        }
        if (scalar(keys %localseqlens) > 1) {
            print "Error: multiple alignment '$maid' contains sequence of different lengths:\n";
            foreach my $len (sort { $a <=> $b } keys %localseqlens) {
                print STDERR " -> ",$localseqlens{$len}, " sequences with length $len\n";
            }
        }

        while (my ($len,$cnt) = each %localseqlens) {
            $seqlens{$len} += $cnt;
        }

    }

    if (scalar(keys %seqlens) > 1) {
        print "Error: overall, your input file contains sequence of different lengths:\n";
        foreach my $len (sort { $a <=> $b } keys %seqlens) {
            print STDERR " -> ",$seqlens{$len}, " sequences with length $len\n";
        }
    }

    if (scalar(keys %numseqs) > 1) {
        print "Error: overall, your input file contains multiple alignments with different number of sequences each:\n";
        foreach my $num (sort { $a <=> $b } keys %numseqs) {
            print STDERR " -> ",$numseqs{$num}, " multiple alignments with $num sequences\n";
        }
    }

}



#######################################
# FASTA input/output
#######################################

sub ReadFastaMultAligns {
    my $text = shift;

    my $content = [];

    for (;;) {
        my @matext = ();
        my %seenids = ();

        while (@$text) {
            my $line = shift(@$text);
            next if $line =~ m#^\s*$|^\s*;#;
            if ($line =~ m#^>\s*(\S+)#) {
                my $id = $1;
                if ($seenids{$id}) {
                    unshift(@$text,$line);
                    last;
                }
                $seenids{$id}++;
            }
            push(@matext,$line);
        }
        last unless @matext;

        my $seqlist = [];
        my $seqobj  = undef;
        my $seq     = "";

        for (my $i = 0; $i < @matext; $i++) {
            my $line = $matext[$i];
            if ($line =~ m#^>(\S+)(\s+.*\S)?\s*$#) {
                my ($newid,$rest) = ($1,$2);
                $rest = "" if !defined($rest);
                if ($seqobj) {
                    $seq = &SeqCleanup($seq);
                    $seqobj->set_sequence($seq);
                }
                $seq="";
                $seqobj = new PirObject::AlignedSeq(
                    seqId        => $newid,
                    seqFastaRest => $rest,
                    sequence     => "",
                );
                push(@$seqlist,$seqobj);
                next;
            }
            $seq .= $line;
        }

        if ($seqobj) { # handle last seq in file
             $seq = &SeqCleanup($seq);
             $seqobj->set_sequence($seq);
        }

        my $ma = new PirObject::MultAlign(
            alignedSeqs => $seqlist,
        );

        push(@$content,$ma);
    }

    $content;
}

sub DumpFastaMultAligns {
    my $fh      = shift;
    my $content = shift;

    foreach my $ma (@$content) {
        my $seqlist = $ma->get_alignedSeqs() || [];
        foreach my $seqobj (@$seqlist) {
            my $text = $seqobj->AsFasta();
            print $fh $text;
        }
    }

}



#######################################
# Phylip-N input/output
#######################################

sub ReadPhylipNMultAligns {
    my $text = shift;

    my $content = [];

    for (;;) {
        my @matext = ();
        shift(@$text) while @$text && $text->[0] =~ m#^\s*$#;
        my $sizeline = @$text ? shift(@$text) : "";  # size line
        push(@matext,shift(@$text)) while @$text && $text->[0] !~ m#^\s*\d+\s+\d+#;
        last unless @matext;

        die "Error: first line of Phylip multiple alignement is incorrect. Expected '<numseq> <seqlength>', got:\n$sizeline\n"
            unless $sizeline =~ m#^\s*([1-9]\d*)\s+([1-9]\d*)#;
        my ($numseq,$length) = ($1,$2);

        my $seqlist = [];
        my $seqobj  = undef;
        my $seq = "";

        for (my $i=0;$i < @matext;$i++) {
            my $line = $matext[$i];
            next if $line =~ m#^\s*$#;

            if (!$seqobj) {
                die "Can't parse line in Phylip alignment file: Line was:\n$line\n"
                    unless $line =~ s#^(\S+)\s*##;
                my $id = $1;
                $line = &SeqCleanup($line);
                $seqobj = new PirObject::AlignedSeq(
                    seqId    => $id,
                    sequence => $line,
                );
                $seq = $line;
                push(@$seqlist,$seqobj);
                $seqobj = undef if length($line) >= $length;
                next;
            }
            $line = &SeqCleanup($line);
            $seq .= $line;
            $seqobj->set_sequence($seq);
            $seqobj = undef if length($seq) >= $length;
        }

        my $ma = new PirObject::MultAlign(
            alignedSeqs => $seqlist,
        );

        push(@$content,$ma);
    }

    $content;
}

sub DumpPhylipNMultAligns {
    my $fh      = shift;
    my $content = shift;

    foreach my $ma (@$content) {
        my $numseq  = $ma->NumSequences();
        my $seqlen  = $ma->AlignmentLength();
        my $seqlist = $ma->get_alignedSeqs() || [];
        print $fh "$numseq\t$seqlen\n";
        foreach my $seqobj (@$seqlist) {
            my $text = $seqobj->AsPhylipN();
            print $fh $text;
        }
    }
}



#######################################
# Phylip-I input/output
#######################################

sub ReadPhylipIMultAligns {
    my $text = shift;

    my $content = [];

    for (;;) {
        my @matext = ();
        shift(@$text) while @$text && $text->[0] =~ m#^\s*$#;
        my $sizeline = @$text ? shift(@$text) : "";  # size line
        push(@matext,shift(@$text)) while @$text && $text->[0] !~ m#^\s*\d+\s+\d+#;
        last unless @matext;

        die "Error: first line of Phylip multiple alignement is incorrect. Expected '<numseq> <seqlength>', got:\n$sizeline\n"
            unless $sizeline =~ m#^\s*([1-9]\d*)\s+([1-9]\d*)#;
        my ($numseq,$length) = ($1,$2);

        my $seqlist = [];
        my $seqobj  = undef;
        my $seq = "";

        shift(@matext) while @matext && $matext[0] =~ m#^\s*$#;
        my $reachedlen = 0;
        while (@matext) {
            for (my $i=0;$i<$numseq;$i++) {
                shift(@matext) while @matext && $matext[0] =~ m#^\s*$#;
                last unless @matext;
                my $line = shift(@matext);
                if (!defined($seqlist->[$i])) {
                    my ($id,$seq) = ($line =~ m#^(\S+)(.*)#);
                    $line = $seq;
                    $seqlist->[$i] = PirObject::AlignedSeq->new(
                        seqId    => $id,
                        sequence => "",
                    );
                }
                $line = &SeqCleanup($line);
                my $seqobj = $seqlist->[$i];
                my $seq    = $seqobj->get_sequence() || "";
                $seq .= $line;
                $seqobj->set_sequence($seq);
                $reachedlen++ if length($seq) >= $length;
            }
            last if $reachedlen; # TODO check that ALL $numseq seqs have reached $length
        }

        my $ma = new PirObject::MultAlign(
            alignedSeqs => $seqlist,
        );

        push(@$content,$ma);
    }

    $content;
}

sub DumpPhylipIMultAligns {
    my $fh      = shift;
    my $content = shift;

    foreach my $ma (@$content) {
        my $numseq  = $ma->NumSequences();
        my $seqlen  = $ma->AlignmentLength();
        my $seqlist = $ma->get_alignedSeqs() || [];
        print $fh "$numseq\t$seqlen\n";
        for (my $i=0;$i < $seqlen;$i += 50) {
            foreach my $seqobj (@$seqlist) {
                my $seq = $seqobj->get_sequence();
                my $remain = length($seq) - $i;
                if ($remain <= 0) { # should never happen
                    print $fh ((" " x 13),"\n");
                    next;
                }
                my $subseq = substr($seq,$i, $remain < 50 ? $remain : 50);
                foreach my $space ( 40, 30, 20, 10 ) {
                    next if $space >= length($subseq);
                    substr($subseq,$space,0) = " ";
                }
                if ($i == 0) {
                    my $id = $seqobj->get_seqId() || "Unknown";
                    $id = substr($id,0,10) if length($id) > 10;
                    $id .= " " while length($id) < 13;
                    print $fh $id,$subseq,"\n";
                } else {
                    print $fh ((" " x 13),$subseq,"\n");
                }
            }
            print $fh "\n";
        }
    }
}



#######################################
# NEXUS input/output
#######################################

sub ReadNexusMultAligns {
    my $text = shift;

    my $content = [];

    for (;;) {
        my @matext = ();
        shift(@$text) while @$text && $text->[0] =~ m#^\s*$#;
        my $nexusline = @$text ? shift(@$text) : "";  # nexus line
        push(@matext,shift(@$text)) while @$text && $text->[0] !~ m/\s*#\s*nexus/i;
        @matext = grep(!m#\s*\[|^\s*$#,@matext);
        last unless @matext;

        die "Error: expected #NEXUS line, got '$nexusline'.\n"
            unless $nexusline =~ m/^\s*#\s*nexus/i;

        my ($numseq,$length) = (0,0);
        while (@matext) {
            my $line = shift @matext;
            last if $line =~ m#^\s*matrix#i;
            next if $line =~ m#begin data#i;
            if ($line =~ m#dimensions\s+ntax=(\d+)\s+nchar=(\d+)#) {
                ($numseq,$length) = ($1,$2);
                next;
            }
            if ($line =~ m#^\s*format#) {
               #format datatype=protein interleave missing=-
               die "Error: cannot parse NEXUS format that is not interleaved.\n"
                   unless $line =~ m#\sinterleave#i;
               # TODO parse other format options?
               next;
            }
            die "Unrecognized NEXUS format line: $line\n";
        }

        die "Could not found ntax and nchar in NEXUS file?!?\n"
            unless $numseq > 0 && $length > 0;

        my $seqlist = [];
        my $seqobj  = undef;
        my $seq = "";

        my $reachedlen = 0;
        while (@matext) {
            for (my $i=0;$i<$numseq;$i++) {
                shift(@matext) while @matext && $matext[0] =~ m#^\s*$#;
                last unless @matext;
                my $line = shift(@matext);
                my ($id,$seq) = ($line =~ m#^\s*(\S+)(.*)#);
                if (!defined($seqlist->[$i])) {
                    $seqlist->[$i] = PirObject::AlignedSeq->new(
                        seqId    => $id,
                        sequence => "",
                    );
                } else {
                    my $curid = $seqlist->[$i]->get_seqId();
                    die "Inconsistency in NEXUS format, got seq line for '$id' expecting one for '$curid'.\n"
                        unless $curid eq $id;
                }
                $seq = &SeqCleanup($seq);
                my $seqobj = $seqlist->[$i];
                my $curseq = $seqobj->get_sequence() || "";
                $curseq .= $seq;
                $seqobj->set_sequence($curseq);
                $reachedlen++ if length($curseq) >= $length;
            }
            last if $reachedlen; # TODO check that ALL $numseq seqs have reached $length
        }

        my $ma = new PirObject::MultAlign(
            alignedSeqs => $seqlist,
        );

        push(@$content,$ma);
    }

    $content;
}

sub DumpNexusMultAligns {
    my $fh      = shift;
    my $content = shift;

    foreach my $ma (@$content) {
        my $numseq  = $ma->NumSequences();
        my $seqlen  = $ma->AlignmentLength();
        my $seqlist = $ma->get_alignedSeqs() || [];
        my $type    = $ma->GuessType() || "Unknown";
        print $fh "#NEXUS\n",
                  "begin data;\n",
                  " dimensions ntax=$numseq nchar=$seqlen;\n",
                  " format datatype=$type interleave missing=-;\n",
                  "  matrix\n";

        for (my $i=0;$i < $seqlen;$i += 100) {
            foreach my $seqobj (@$seqlist) {
                my $seq = $seqobj->get_sequence();
                my $remain = length($seq) - $i;
                if ($remain <= 0) { # should never happen
                    print $fh ((" " x 11),"\n");
                    next;
                }
                my $subseq = substr($seq,$i, $remain < 100 ? $remain : 100);
                foreach my $space ( 80, 60, 40, 20 ) {
                    next if $space >= length($subseq);
                    substr($subseq,$space,0) = " ";
                }
                my $id = $seqobj->get_seqId() || "Unknown";
                $id = substr($id,0,9) if length($id) > 9;
                $id = " $id" while length($id) < 9;
                print $fh $id,"  ",$subseq,"\n";
            }
            print $fh "\n";
        }

        print $fh ";\n",
                  "  end;\n";

    }
}



#######################################
# CLUSTAL input/output
#######################################

sub ReadClustalMultAligns {
    my $text = shift;

    my $content = [];

    for (;;) {
        my @matext = ();
        shift(@$text) while @$text && $text->[0] =~ m#^\s*$#;
        my $headerline = @$text ? shift(@$text) : "";  # constant "CLUSTAL X"
        push(@matext,shift(@$text)) while @$text && $text->[0] !~ m#^CLUSTAL X#;
        last unless @matext;

        die "Error: first line of Clustal multiple alignement is incorrect. Expected 'CLUSTAL X', got:\n$headerline\n"
            unless $headerline =~ m#^CLUSTAL X#;
        my ($numseq,$length) = (0,0);

        my $seqlist = [];
        my $seqobj  = undef;
        my $seq = "";

#Coccidoides.pos               ACACTCGTGCGAGCAATCCACGAACGG-CTG-----------TGGCGCGC

        shift(@matext) while @matext && $matext[0] =~ m#^\s*$#;
        while (@matext) {
            for (my $i=0;;$i++) {
                last unless @matext;
                last if @matext && $matext[0] =~ m#^\s*$#;
                my $line = shift(@matext);
                my ($id,$rest) = ($line =~ m#^(.{30,30})(\S+)#);
                if (!defined($seqlist->[$i])) {
                    $id =~ s/\s*$//;
                    $seqlist->[$i] = PirObject::AlignedSeq->new(
                        seqId    => $id,
                        sequence => "",
                    );
                }
                $rest = &SeqCleanup($rest);
                my $seqobj = $seqlist->[$i];
                my $seq    = $seqobj->get_sequence() || "";
                $seq .= $rest;
                $seqobj->set_sequence($seq);
            }
            shift(@matext) while @matext && $matext[0] =~ m#^\s*$#
        }

        my $ma = new PirObject::MultAlign(
            alignedSeqs => $seqlist,
        );

        push(@$content,$ma);
    }

    $content;
}

sub DumpClustalMultAligns {
    my $fh      = shift;
    my $content = shift;

    foreach my $ma (@$content) {
        my $numseq  = $ma->NumSequences();
        my $seqlen  = $ma->AlignmentLength();
        my $seqlist = $ma->get_alignedSeqs() || [];
        print $fh "CLUSTAL X\n\n";
        for (my $i=0;$i < $seqlen;$i += 50) {
            print $fh "\n";
            foreach my $seqobj (@$seqlist) {
                my $seq = $seqobj->get_sequence();
                my $remain = length($seq) - $i;
                if ($remain <= 0) { # should never happen
                    die "Internal error clustal W\n";
                }
                my $subseq = substr($seq,$i, $remain < 50 ? $remain : 50);
                my $id = $seqobj->get_seqId() || "Unknown";
                $id = substr($id,0,29) if length($id) > 29;
                $id .= " " while length($id) < 29;
                print $fh $id," ",$subseq,"\n";
            }
            print $fh "\n";
        }
    }
}



#######################################
# GDE input/output
#######################################

sub ReadGDEMultAligns {
    my $text = shift;

    die "GDE input not supported yet.\n";
}

sub DumpGDEMultAligns {
    my $fh      = shift;
    my $content = shift;

    foreach my $ma (@$content) {  # TODO: cannot differentiate between multiple multaligns
        my $numseq  = $ma->NumSequences();
        my $seqlen  = $ma->AlignmentLength();
        my $seqlist = $ma->get_alignedSeqs() || [];

        foreach my $seqobj (@$seqlist) {
            my $seq   = $seqobj->get_sequence();
            my $id    = $seqobj->get_seqId()        || "Unknown";
            my $rest  = $seqobj->get_seqFastaRest() || "";

            my $seqlet = $seq; $seqlet =~ tr/a-zA-Z//cd; # not SeqCleanup!
            my $acgtn = ($seqlet =~ tr/acgtnACGTN/acgtnACGTN/);
            my $type  = ($acgtn > .8 * length($seqlet) ? "DNA" : "PROTEIN");

            my $prettyseq = "";
            $seq =~ tr/~/-/;
            for (my $i=0;$i < length($seq);$i += 50) {
                my $len = length($seq) - $i; $len = 50 if $len > 50;
                $prettyseq .= substr($seq,$i,$len) . "\n";
            }
            print $fh <<GDERECORD;
{
name        "$id"
type        "$type"
descrip     "$rest"
sequence    "
$prettyseq"
}
GDERECORD
        }
    }
}



#######################################
# RAW format input/output
#######################################

sub ReadRAWMultAligns {
    my $text = shift;

    die "RAW input not supported yet.\n";
}

sub DumpRAWMultAligns {
    my $fh      = shift;
    my $content = shift;

    foreach my $ma (@$content) {  # TODO: cannot differentiate between multiple multaligns
        my $numseq  = $ma->NumSequences();
        my $seqlen  = $ma->AlignmentLength();
        my $seqlist = $ma->get_alignedSeqs() || [];

        foreach my $seqobj (@$seqlist) {
            my $seq   = $seqobj->get_sequence();
            #my $id    = $seqobj->get_seqId()        || "Unknown";
            #my $rest  = $seqobj->get_seqFastaRest() || "";

            print $seq,"\n";
        }
    }
}



#######################################
# STOCKHOLM format input/output
#######################################

sub ReadStockholmMultAligns {
    my $text = shift;

    die "STOCKHOLM input not supported yet.\n";
}

sub DumpStockholmMultAligns {
    my $fh      = shift;
    my $content = shift;

    my $namelen = 23;
    my $seqlen = 100;

    foreach my $ma (@$content) {
        my $numseq  = $ma->NumSequences();
        my $seqlen  = $ma->AlignmentLength();
        my $seqlist = $ma->get_alignedSeqs() || [];

        # Move 'structure' sequences to the end of the list
        for (my $c = 0; $c < $STRUCTURES;$c++) {
            my $structobj = shift @$seqlist;
            my $structseq = $structobj->get_sequence() || "";

            my $seq = &TransformIntoStockholmStruct($structseq);
            $structobj->set_sequence($seq);
            $structobj->set_seqId("#=GC SS_cons");
            push(@$seqlist,$structobj);

            my $maskobj = new PirObject::AlignedSeq(
                seqId        => "#=GC RF",
                sequence     => $structseq,  # as is
            );
            push(@$seqlist, $maskobj);
        }

        print $fh "# STOCKHOLM 1.0\n";

        for (my $i=0;$i < $seqlen;$i += $seqlen) {
            print $fh "\n";
            for (my $s=0; $s < @$seqlist;$s++) {
                my $seqobj = $seqlist->[$s];
                my $seq = $seqobj->get_sequence();
                my $remain = length($seq) - $i;
                $remain = 0 if ($remain <= 0);
                my $subseq = substr($seq,$i, $remain < $seqlen ? $remain : $seqlen);
                my $id = $seqobj->get_seqId() || "Unknown";
                $id = substr($id,0,$namelen) if length($id) > $namelen;
                $id .= " " while length($id) < $namelen;
                print $fh $id," ",$subseq,"\n";
            }
        }

        print $fh "//\n";
    }
}

sub TransformIntoStockholmStruct {
    my $seq = shift;
    my %seenUppercasePos=();
    my @seq = split(m//,$seq);
    for (my $pos=0;$pos < @seq;$pos++) {
        my $c = $seq[$pos];
        if ($c !~ m#^[A-Z]$#) {
            $seq[$pos]=".";
            next;
        }
        if (!exists($seenUppercasePos{$c})) {
            $seq[$pos]="<";
        } elsif ($seenUppercasePos{$c} == $pos-1) {
            $seq[$pos]=$seq[$pos-1];
        } else {
            $seq[$pos]=">";
        }
        $seenUppercasePos{$c}=$pos;
    }
    join("",@seq);
}
